<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>DigiDrop the HTML game - POC by ReGaSLZR</title>

    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
</head>
<body>
<script type="text/javascript">

/* DIMENSIONS */
var screenWidth = 360;
var screenHeight = 640;

var replayWidth = 75;
var replayHeight = 75;

var basketWidth = 202;
var basketHeight = 109;

var characterPlayerWidth = 157;
var characterPlayerHeight = 166;

var destroyerHeight = 10;

var coinWidth = 50;
var coinHeight = 50;

var soundTriggerWidth = 51;
var soundTriggerHeight = 55;
var soundTriggerPadding = 14;

/* CONFIG VALUES */

var maxCoinsPerWave = 10;
var coinMaxYOnSpawn = 50;

var countDown = 15; //in seconds
var tenseTimeMark = 5;
var timerLabel = 'Time Left: ';

var gameOverLabel = 'Thanks for playing.\nYou won 100 points.';

var instructionLabel = 'Drag the character\nand catch coins.';
var instructionCountdown = 2;

/* GLOBAL VARIABLES */

var timedEvent;
var timerText;
var timerTextLabel;

var audioBgm;
var sfxCoin;

var gameOverText;

var instructionText;

var isSoundOn = true;
var buttonReplay;
var buttonSoundTrigger;

var config = {
    type: Phaser.AUTO,
    width: screenWidth,
    height: screenHeight,
    // backgroundColor: '#ff0000',
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 300 },
            debug: false
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    },
};

var game = new Phaser.Game(config);

var basketPlayer;
var charPlayer;
var coinGroup;
var destroyerGroup;

function preload ()
{
    this.load.image('replay', 'assets/replay.png');
    this.load.image('destroyer', 'assets/block.png');
    this.load.spritesheet('coin', 'assets/coin-sheet.png',
        { frameWidth: coinWidth, frameHeight: coinHeight });

    this.load.audio('bgm', 'assets/Kevin_MacLeod_Amazing_Plan.mp3');
    this.load.audio('sfxCoinCaught', 'assets/freesound-coin.wav');

    /* SPECIFICS */
    this.load.image('imgBg', 'assets/digi-bg.png');

    this.load.spritesheet('audiocontrol', 'assets/audiocontrol-sheet.png', { frameWidth: soundTriggerWidth, frameHeight: soundTriggerHeight });

    this.load.spritesheet('basket', 'assets/basket-sheet.png', 
        { frameWidth: basketWidth, frameHeight: basketHeight });

    this.load.spritesheet('characterPlayer', 'assets/character-sheet.png', 
        { frameWidth: characterPlayerWidth, frameHeight: characterPlayerHeight });

}

function create ()
{
    this.add.image(0, 0, 'imgBg').setOrigin(0, 0);

    prepareAudio(this);
    prepareDestroyer(this);
    preparePlayer(this);
    prepareCoins(this);
    prepareColliders(this);
    prepareButtonReplay(this);
    prepareAudioToggle(this);
    prepareTimer(this);

    prepareGUIText(this);
}

function prepareGUIText(preparer) {
    instructionText = preparer.add.text(
        (screenWidth/9), 
        ((screenHeight/2) - (screenHeight/9)), 
        (instructionLabel), 
        { fontFamily: 'Arial', fontSize: 32, color: '#00ff00', align: 'center' });

    timerTextLabel = preparer.add.text(
        8, 
        8, 
        (timerLabel), 
        { fontFamily: 'AvenirNext-Bold', fontSize: 16, color: '#fdbb2f' });

    timerText = preparer.add.text(
        8, 
        25, 
        getUpdatedTimeRemaining(), 
        { fontFamily: 'AvenirNext-Bold', fontSize: 32, color: '#ffffff' });

    gameOverText = preparer.add.text(
        (screenWidth/9), 
        ((screenHeight/2) - (screenHeight/4)), 
        (gameOverLabel), 
        { fontFamily: 'Arial', fontSize: 32, color: '#00ff00', align: 'center' });

    gameOverText.visible = false;
}

function prepareAudio(preparer) {
    /* AUDIO */
    sfxCoin = preparer.sound.add('sfxCoinCaught');
    audioBgm = preparer.sound.add('bgm');
    audioBgm.play();
}

function prepareCoins(preparer) {
/* Coin Animation + Group and Children creation */
    preparer.anims.create({
        key: 'coinTurn',
        frames: preparer.anims.generateFrameNumbers('coin', { start: 0, end: 9 }),
        frameRate: 10,
        repeat: -1
    });

    coinGroup = preparer.physics.add.group();
    for(var x=0; x<maxCoinsPerWave; x++) {
        var coin = coinGroup.create(
            Phaser.Math.Between(0, screenWidth-coinWidth),
            Phaser.Math.Between(0, coinMaxYOnSpawn), 
            'coin');

        coin.anims.play('coinTurn');
    }
}

function prepareColliders(preparer) {
    preparer.physics.add.collider(charPlayer, destroyerGroup);
    preparer.physics.add.collider(basketPlayer, charPlayer);
    // preparer.physics.add.collider(basketPlayer, destroyerGroup);

    preparer.physics.add.overlap(destroyerGroup, coinGroup, destroyCoin, null, preparer);
    preparer.physics.add.overlap(basketPlayer, coinGroup, catchCoin, null, preparer);
}

function prepareDestroyer(preparer) {
    destroyerGroup = preparer.physics.add.staticGroup();
    var tempHeight = (screenHeight + 15);
    for(var x=0; x<screenWidth; x++) {
        destroyerGroup.create(x, tempHeight, 'destroyer');
    }    
}

function prepareButtonReplay(preparer) {
    buttonReplay = preparer.add.image(
        (screenWidth - replayWidth), 
        (screenHeight - replayHeight),
        'replay')
    .setOrigin(0, 0)
    .setInteractive();

    buttonReplay.on('pointerdown', function (pointer) {
        location.reload();
    });
    buttonReplay.visible = false;
}

function preparePlayer(preparer) {
    basketPlayer = preparer.physics.add.sprite(
        (screenWidth/2), 
        (screenHeight - (characterPlayerHeight + (basketHeight/4))),
        'basket');
    basketPlayer.body.allowGravity = false;     

    preparer.anims.create({
        key: 'basket0',
        frames: [ { key: 'basket', frame: 0 } ]
    });
    preparer.anims.create({
        key: 'basket1',
        frames: [ { key: 'basket', frame: 1 } ]
    });
    preparer.anims.create({
        key: 'basket2',
        frames: [ { key: 'basket', frame: 2 } ]
    });
    preparer.anims.create({
        key: 'basket3',
        frames: [ { key: 'basket', frame: 3 } ]
    });
    preparer.anims.create({
        key: 'basket4',
        frames: [ { key: 'basket', frame: 4 } ]
    });    

    preparer.anims.create({
        key: 'charNormal',
        frames: [ {key: 'characterPlayer', frame: 0 } ]
    });

    preparer.anims.create({
        key: 'charDragged',
        frames: [ {key: 'characterPlayer', frame: 1 } ]
    });
    preparer.anims.create({
        key: 'charDraggedTense',
        frames: [ {key: 'characterPlayer', frame: 2 } ]
    });

    charPlayer = preparer.physics.add.sprite(
        (screenWidth/2), 
        (screenHeight - (characterPlayerHeight/2)), 
        'characterPlayer')
    .setInteractive();

    preparer.input.setDraggable(charPlayer);

    preparer.input.on('drag', function (pointer, gameObject, dragX, dragY) {
        gameObject.x = dragX;
        basketPlayer.x = dragX;

        charPlayerEmotion_animateDragged();
    });

    preparer.input.on('pointerup', function() {
        charPlayerEmotion_animateNormal();
    });

    preparer.input.on('pointerout', function() {
        charPlayerEmotion_animateNormal();
    });
}

function charPlayerEmotion_animateNormal() {
    charPlayer.anims.play('charNormal', false);
}

function charPlayerEmotion_animateDragged() {
    if(timedEvent.repeatCount <= tenseTimeMark) {
        charPlayer.anims.play('charDraggedTense', false);
    } else {
        charPlayer.anims.play('charDragged', false);
    }
}

function prepareAudioToggle(preparer) {
    buttonSoundTrigger = preparer.add.sprite(
        (screenWidth - (soundTriggerWidth + soundTriggerPadding)),
        (soundTriggerPadding),
        'audiocontrol')
    .setOrigin(0, 0)
    .setInteractive();

    preparer.anims.create({
        key: 'audioOff',
        frames: [ { key: 'audiocontrol', frame: 0 } ]
    });
    preparer.anims.create({
        key: 'audioOffPressed',
        frames: [ { key: 'audiocontrol', frame: 1 } ]
    });
    preparer.anims.create({
        key: 'audioOn',
        frames: [ { key: 'audiocontrol', frame: 2 } ]
    });

    preparer.anims.create({
        key: 'audioOnPressed',
        frames: [ { key: 'audiocontrol', frame: 3 } ]
    });

    buttonSoundTrigger.anims.play('audioOn', false);

    buttonSoundTrigger.on('pointerdown', function (pointer) {
        toggleSound();

        if(isSoundOn) {
            buttonSoundTrigger.anims.play('audioOff', false);    
        } else {
            buttonSoundTrigger.anims.play('audioOn', false);    
        }
    });

    buttonSoundTrigger.on('pointerover', function () {
        if(isSoundOn) {
            buttonSoundTrigger.anims.play('audioOnPressed');
        } else {
            buttonSoundTrigger.anims.play('audioOffPressed');
        }
    });

    buttonSoundTrigger.on('pointerup', function() {
        unPressSoundTrigger();
    });

    buttonSoundTrigger.on('pointerout', function() {
        unPressSoundTrigger();
    });
}

function prepareTimer(preparer) {
    timedEvent = preparer.time.addEvent({ 
            delay: 1000, 
            callback: onCountdownTick, 
            callbackScope: preparer, 
            repeat: countDown 
        });
}

function unPressSoundTrigger() {
    if(isSoundOn) {
        buttonSoundTrigger.anims.play('audioOn');
    } else {
        buttonSoundTrigger.anims.play('audioOff');
    }
}

function toggleSound() {
    audioBgm.mute = isSoundOn;
    sfxCoin.mute = isSoundOn;

    isSoundOn = !isSoundOn;
}

function animateBasket(basket) {
    var remainingTime = timedEvent.repeatCount;

    if(remainingTime >= 13) {
        basket.anims.play('basket0', false);
    }
    else if(remainingTime >= 10) {
        basket.anims.play('basket1', false);
    }
    else if(remainingTime >= 8) {
        basket.anims.play('basket2', false);
    }
    else if(remainingTime >= 4) {
        basket.anims.play('basket3', false);
    }
    else {
        basket.anims.play('basket4', false);
    }
}

function onCountdownTick() {
    timerText.setText(getUpdatedTimeRemaining());

    if(instructionCountdown > 0) {
        instructionCountdown--;
    } else {
        instructionText.visible = false;
    }


    if(timedEvent.repeatCount == tenseTimeMark) {
        timerText.setColor('#f00');
    }
    else if(timedEvent.repeatCount == 0) {
        audioBgm.stop();
        showGameOverScreen();
    }
}

function getUpdatedTimeRemaining() {
    var remainingMinutes = ((timedEvent.repeatCount/60) | 0);
    var remainingSeconds = (timedEvent.repeatCount >= 60) ? 
    (timedEvent.repeatCount % 60) : timedEvent.repeatCount;
    var concatenator = (remainingSeconds >= 10) ? ':' : ':0';

    return (remainingMinutes + concatenator + remainingSeconds);
}

function catchCoin(basket, coin) {
    coin.disableBody(true, true);
    sfxCoin.play();

    animateBasket(basket);
    relocateCoin(coin);
}

function destroyCoin(destroyerGroup, coin) {
    coin.disableBody(true, true);
    relocateCoin(coin);
}

function relocateCoin(coin) {
    if(timedEvent.repeatCount > 0) {
        coin.enableBody(
            true, 
            Phaser.Math.Between(0, (screenWidth-coinWidth)), 
            Phaser.Math.Between(0, coinMaxYOnSpawn), 
            true,
            true
        );
    }
}

function showGameOverScreen() {
    basketPlayer.destroy();
    charPlayer.destroy();

    timerText.visible = false;
    timerTextLabel.visible = false;

    gameOverText.visible = true;
    buttonReplay.visible = true;
    buttonSoundTrigger.visible = false;
}

function update ()
{

}

</script>

</body>
</html>